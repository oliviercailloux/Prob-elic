# -*- coding: utf-8 -*-
"""Counting orderings V2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eELkG-2X6NIOuF6gHEv223vxADXdxZ18
"""

import numpy as np
from itertools import permutations
from itertools import combinations
#from itertools import compress
#from itertools import filterfalse
from anytree import Node, RenderTree
from anytree.dotexport import RenderTreeGraph
from anytree import dotexport

# V2 now creates question nodes in the rendered tree, and computes
# expected values for question nodes

n=6

# At any level, any question that is not 'connected' to any other is symmetrical.
# Hence we give only one in the decision tree.

# A node is an answer to a question

class Elic_node:
  def __init__(self,n,r_node=None,question=None,f_node=None,sym_question=False,index=None):
    #f_node = father node
    #sym_question = True if question has symmetrical answers, else False
    if r_node is None:
      A=list(range(n))
      self._perms=np.array(list(permutations(A)))
      self._descriptor=''
      self._mask=np.ones((self._perms.shape[0]),dtype=np.bool_)
      self._depth=0
      self._items=[]
      self._f_node=None
      self._known_answers=[]
      self._isquestion=False
      self._num_compat=self._perms.shape[0]
      self._long_description=self._descriptor+','+str(self._num_compat)+','+str(len(self._known_answers))
      self._child_indices=[]
      self._index=0
    elif f_node._isquestion == True:
      self._isquestion=False
      x1=question[0]
      x2=question[1]
      new_cases=np.array(list(map(lambda x:x[x1]>x[x2],r_node._perms[f_node._f_node._mask])),dtype=np.bool_)
      self._mask=f_node._f_node._mask.copy()
      self._mask[self._mask]=new_cases
      self._descriptor=f_node._f_node._descriptor+'('+str(x1)+'>'+str(x2)+')'
      self._items=f_node._f_node._items.copy()
      if not(x1 in self._items):
        self._items.append(x1)
      if not(x2 in self._items):
        self._items.append(x2)
      self._depth=f_node._f_node._depth+1
      self._f_node=f_node
      self._x1=x1
      self._x2=x2
      self._known_answers=f_node._f_node._known_answers.copy()
      self.add_known_answer(x1,x2)
      #self._num_compat=sum(self._mask)
      self._num_compat=np.count_nonzero(self._mask)
      self._long_description=self._descriptor+','+str(self._num_compat)+','+str(len(self._known_answers))
      self._child_indices=[]
      self._index=index
      self._f_node._child_indices.append(index)
    else:
      x1=question[0]
      x2=question[1]
      self._f_node=f_node
      self._depth=f_node._depth
      self._x1=x1
      self._x2=x2
      self._expected_value=None
      self._descriptor='question'
      self._long_description='('+str(x1)+'>'+str(x2)+')?'
      self._isquestion=True
      self._issymquestion=sym_question
      self._num_compat=self._f_node._num_compat
      self._known_answers=None
      self._child_indices=[]
      self._index=index
      self._f_node._child_indices.append(index)
      

  def describe(self):
    if self._descriptor=='':
      print('root_node')
    else:
      print(self._descriptor)
      if self._isquestion:
        print(self._long_description)
      else:
        print(self._num_compat, 'compatible orders, ',len(self._known_answers), 'preferences known.' )
  
  def add_known_answer(self,x1,x2):
      self._known_answers.append((x1,x2))
      for answer in self._known_answers:
        if answer[0]==x2 and (x1,answer[1]) not in self._known_answers:
          self.add_known_answer(x1,answer[1])
        if answer[1]==x1 and ((answer[0],x2)) not in self._known_answers:
          self.add_known_answer(answer[0],x2)
      

class Elic_Tree:
    
  def __init__(self,n,k):
    #n : number of items
    #k: number of questions
    self._n=n
    self._k=k
    self._nodes=[Elic_node(n)]
    self._parents=[]
    self._open_nodes=[0]
  
  def next_questions(self,node_index):
    #outputs all pairs of possible answers to questions as a list of pairs
    #trivially symmetrical cases are ignored
    node= self._nodes[node_index]
    items=node._items.copy()
    if len(node._items)==0:
      max_item=-1
    else:
      max_item=max(node._items)
    if max_item < self._n -1:
      items.append(max_item+1)
    questions=set(combinations(items,2))
    to_remove=set({})
    for question in questions:
      if question in node._known_answers or (question[1],question[0]) in node._known_answers:
        to_remove.add(question)
    for question in to_remove:
        questions.remove(question)
    if max_item < self._n -2:
      questions.add((max_item+1))
    return questions

  def open_first_node(self):
    node_index=self._open_nodes.pop(0)
    if self._nodes[node_index]._isquestion==False:
      questions=self.next_questions(node_index)
      for i,question in enumerate(questions):
        new_node_index=len(self._nodes)
        if type(question)==tuple:
          self._nodes.append(Elic_node(n,self._nodes[0],question,self._nodes[node_index],False,new_node_index))
          self._parents.append(node_index)
          if self._nodes[new_node_index]._depth<self._k:
            self._open_nodes.append(new_node_index)
        else:
          self._nodes.append(Elic_node(n,self._nodes[0],[question,question+1],self._nodes[node_index],True,new_node_index))
          self._parents.append(node_index)
          if self._nodes[new_node_index]._depth<self._k:
            self._open_nodes.append(new_node_index)

    else:
      new_node_index=len(self._nodes)
      question=[self._nodes[node_index]._x1,self._nodes[node_index]._x2]
      self._nodes.append(Elic_node(n,self._nodes[0],question,self._nodes[node_index],False,new_node_index))
      self._parents.append(node_index)
      if self._nodes[new_node_index]._depth<self._k:
        self._open_nodes.append(new_node_index)
      if not self._nodes[node_index]._issymquestion:
        self._nodes.append(Elic_node(n,self._nodes[0],[question[1],question[0]],self._nodes[node_index],False,new_node_index+1))
        self._parents.append(node_index)
        new_node_index=len(self._nodes)-1
        if self._nodes[new_node_index]._depth<self._k:
          self._open_nodes.append(new_node_index)

  def compute_expected_values(self):
    for i, node in reversed(list(enumerate(self._nodes))):
      if node._isquestion:
        son_indices=node._child_indices
        if node._num_compat==0:
            print('0 cases:'+node._long_description+' with father'+node._f_node._long_description)
        node._EV=sum(self._nodes[son_index]._EV*self._nodes[son_index]._num_compat for son_index in son_indices)/node._num_compat
        if node._issymquestion:
          node._EV=node._EV*2
      else:
        if node._depth==self._k:
          node._EV=len(node._known_answers)
          node._best_sons=[]
        else:
          son_indices=node._child_indices
          node._EV=max([self._nodes[son_index]._EV for son_index in son_indices])
          node._best_sons=[son_index for son_index in son_indices if self._nodes[son_index]._EV==node._EV]
  
  def compute_best_lists(self):
    self._best_indices=[0]
    self._best_parents=[]
    open=self._nodes[0]._best_sons
    self._nodes[0]._best_description=self._nodes[0]._long_description+','+str(self._nodes[0]._EV)
    while len(open)>0:
      node_index=open.pop(0)
      node=self._nodes[node_index]
      self._best_indices.append(node_index)
      self._best_parents.append(self._best_indices.index(self._parents[node_index-1]))
      if node._isquestion:
        son_indices=[idx+1 for idx in range(len(self._parents)) if self._parents[idx] == node_index]
        for son_index in son_indices:
          open.append(son_index)
        node._best_description=node._long_description+','+str(node._EV)
      else:
        son_indices=node._best_sons
        for son_index in son_indices:
          open.append(son_index)
        node._best_description=node._long_description+','+str(node._EV)
  
  def render_best(self):
    Nodes=[Node(self._nodes[0]._best_description)]
    for i in range(len(self._best_indices)-1):
      Nodes.append(Node(self._nodes[self._best_indices[i+1]]._best_description,parent=Nodes[self._best_parents[i]]))
    for pre, fill, node in RenderTree(Nodes[0]):
      print("%s%s" % (pre, node.name))

  def render(self):
    Nodes=[Node(self._nodes[0]._long_description)]
    for i in range(len(self._nodes)-1):
      Nodes.append(Node(self._nodes[i+1]._long_description,parent=Nodes[self._parents[i]]))
    for pre, fill, node in RenderTree(Nodes[0]):
      print("%s%s" % (pre, node.name))
  

  def dot_render(self):
    Nodes=[Node(self._nodes[0]._long_description)]
    for i in range(len(self._nodes)-1):
      Nodes.append(Node(self._nodes[i+1]._long_description,parent=Nodes[self._parents[i]]))
    for Line in RenderTreeGraph(Nodes[0]):
      print(Line)

  def dot_export(self):
    Nodes=[Node(self._nodes[0]._long_description)]
    for i in range(len(self._nodes)-1):
      Nodes.append(Node(self._nodes[i+1]._long_description,parent=Nodes[self._parents[i]]))
    e = dotexport.DotExporter(Nodes[0])
    e.to_dotfile(str(self._n)+'-'+str(self._k)+'.dot')
    
  def build_whole_tree(self):
    while len(self._open_nodes)>0:
      self.open_first_node()

    

tree=Elic_Tree(7,6)
tree.build_whole_tree()
#tree.render()
tree.compute_expected_values()
tree.compute_best_lists()
tree.render_best()

