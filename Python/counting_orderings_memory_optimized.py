# -*- coding: utf-8 -*-
"""Counting orderings V2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eELkG-2X6NIOuF6gHEv223vxADXdxZ18
"""

import numpy as np
from itertools import permutations
from itertools import combinations
#from itertools import compress
#from itertools import filterfalse
from anytree import Node, RenderTree
from anytree.dotexport import RenderTreeGraph
from anytree import dotexport
import time
# V2 now creates question nodes in the rendered tree, and computes
# expected values for question nodes

n=6

# At any level, any question that is not 'connected' to any other is symmetrical.
# Hence we give only one in the decision tree.

# A node is an answer to a question

class Elic_node:
  def __init__(self,n,r_node=None,question=None,f_node=None,sym_question=False,index=None):
    #f_node = father node
    #sym_question = True if question has symmetrical answers, else False
    if r_node is None:
      self._descriptor=''
      self._depth=0
      self._items=[]
      self._f_node=None
      self._known_answers=[]
      self._direct_answers=[]
      self._isquestion=False
      self._child_indices=[]
      self._index=0
      self._long_description=''
      self._median_node=None
    elif f_node._isquestion == True: #answer node
      self._isquestion=False
      x1=question[0]
      x2=question[1]
      self._descriptor=f_node._f_node._descriptor+'('+str(x1)+'>'+str(x2)+')'
      self._items=f_node._f_node._items.copy()
      if not(x1 in self._items):
        self._items.append(x1)
      if not(x2 in self._items):
        self._items.append(x2)
      self._depth=f_node._f_node._depth+1
      self._f_node=f_node
      self._x1=x1
      self._x2=x2
      self._known_answers=f_node._f_node._known_answers.copy()
      self._direct_answers=f_node._f_node._direct_answers.copy()
      self.add_known_answer(x1,x2)
      self._new_answer=(x1,x2)
      self._direct_answers.append((x1,x2))
      #self._num_compat=sum(self._mask)
      self._child_indices=[]
      self._index=index
      self._f_node._child_indices.append(index)
      self._median_node=self._f_node._f_node._median_node
    else: #question node
      x1=question[0]
      x2=question[1]
      self._f_node=f_node
      self._depth=f_node._depth
      self._x1=x1
      self._x2=x2
      self._expected_value=None
      self._long_description='('+str(x1)+'>'+str(x2)+')?'
      self._descriptor='('+str(x1)+'>'+str(x2)+')?'
      self._isquestion=True
      self._issymquestion=sym_question
      self._known_answers=None
      self._child_indices=[]
      self._index=index
      self._f_node._child_indices.append(index)
      

  def describe(self):
    if self._descriptor=='':
      print('root_node')
    else:
      print(self._descriptor)
  
  def add_known_answer(self,x1,x2):
      self._known_answers.append((x1,x2))
      for answer in self._known_answers:
        if answer[0]==x2 and (x1,answer[1]) not in self._known_answers:
          self.add_known_answer(x1,answer[1])
        if answer[1]==x1 and ((answer[0],x2)) not in self._known_answers:
          self.add_known_answer(answer[0],x2)
          
  def num_higher_nodes(self,x1):
      # return number of of nodes ranked higher than x1 in current node
      return sum(answer[1]==x1 for answer in self._known_answers)
    
  def num_lower_nodes(self,x1):
      # return number of of nodes ranked lower than x1 in current node
      return sum(answer[0]==x1 for answer in self._known_answers)

  
      

class Elic_Tree:
    
  def __init__(self,n,k):
    #n : number of items
    #k: number of questions
    self._n=n
    self._k=k
    self._nodes=[Elic_node(n)]
    self._parents=[]
    self._open_nodes=[0]
    A=list(range(n))
    self._perms=np.array(list(permutations(A)))
    self._num_perms=self._perms.shape[0]
  
  def next_questions(self,node_index):
    #outputs all pairs of possible answers to questions as a list of pairs
    #trivially symmetrical cases are ignored
    node= self._nodes[node_index]
    items=node._items.copy()
    if len(node._items)==0:
      max_item=-1
    else:
      max_item=max(node._items)
    if max_item < self._n -1:
      items.append(max_item+1)
    questions=set(combinations(items,2))
    to_remove=set({})
    for question in questions:
      if question in node._known_answers or (question[1],question[0]) in node._known_answers:
        to_remove.add(question)
    for question in to_remove:
        questions.remove(question)
    if max_item < self._n -2:
      questions.add((max_item+1))
    return questions

  def next_question(self,node_index,strategy):
    #strategy 'NAIVE' or 'ADVANCED'
    node= self._nodes[node_index]
    #items=node._items.copy()
    if node._depth==0:
        return [(0)]#symmetrical question (0,1)
    if node._depth==1:
        return [(1,2)]
    if node._depth==2:
        if len(node._known_answers)==3:#1 is median
            node._median_node=1
            return [(1,3)]
        else:
            return[(0,2)]
    if node._depth==3:
        if node._median_node==1:
            return [(1,4)]
        else:#median is either 0 or 2
            if node.num_higher_nodes(0)==node.num_lower_nodes(0):
                node._median_node=0
            else:
                node._median_node=2
            return [(node._median_node,3)]
    else:
        if strategy=='NAIVE':
            return [(node._median_node,len(node._items))]
        else:
            return [(node._median_node,len(node._items))]
              


  def open_first_node(self,strategy=None):
    node_index=self._open_nodes.pop(0)
    if self._nodes[node_index]._isquestion==False:
      if strategy is None:
          questions=self.next_questions(node_index)
      else:
          questions=self.next_question(node_index,strategy)
      for i,question in enumerate(questions):
        new_node_index=len(self._nodes)
        if type(question)==tuple:
          self._nodes.append(Elic_node(n,self._nodes[0],question,self._nodes[node_index],False,new_node_index))
          self._parents.append(node_index)
          if self._nodes[new_node_index]._depth<self._k:
            self._open_nodes.append(new_node_index)
        else:
          self._nodes.append(Elic_node(n,self._nodes[0],[question,question+1],self._nodes[node_index],True,new_node_index))
          self._parents.append(node_index)
          if self._nodes[new_node_index]._depth<self._k:
            self._open_nodes.append(new_node_index)

    else:
      new_node_index=len(self._nodes)
      question=[self._nodes[node_index]._x1,self._nodes[node_index]._x2]
      self._nodes.append(Elic_node(n,self._nodes[0],question,self._nodes[node_index],False,new_node_index))
      self._parents.append(node_index)
      if self._nodes[new_node_index]._depth<self._k:
        self._open_nodes.append(new_node_index)
      if not self._nodes[node_index]._issymquestion:
        self._nodes.append(Elic_node(n,self._nodes[0],[question[1],question[0]],self._nodes[node_index],False,new_node_index+1))
        self._parents.append(node_index)
        new_node_index=len(self._nodes)-1
        if self._nodes[new_node_index]._depth<self._k:
          self._open_nodes.append(new_node_index)

  def compute_expected_values(self):
    for i, node in reversed(list(enumerate(self._nodes))):
      if node._isquestion:
        if node._issymquestion:
            child_probabilities=[1]
            #compute descriptor for child
            child_index=node._child_indices[0]
            self._nodes[child_index]._long_description=self._nodes[child_index]._descriptor+',p(0.5),'+str(len(self._nodes[child_index]._known_answers))
        else:
            # compute mask for and num_compat child nodes
            mask=np.ones((self._num_perms),dtype=np.bool_)
            for answer in node._f_node._direct_answers:
                x1=answer[0]
                x2=answer[1]
                new_cases=np.array(list(map(lambda x:x[x1]>x[x2],self._perms[mask])),dtype=np.bool_)
                mask[mask]=new_cases
            f_num_compat=np.count_nonzero(mask)
            answer=self._nodes[node._child_indices[0]]._new_answer
            x1=answer[0]
            x2=answer[1]
            new_cases=np.array(list(map(lambda x:x[x1]>x[x2],self._perms[mask])),dtype=np.bool_)
            mask[mask]=new_cases
            child_num_compat=np.count_nonzero(mask)
            proba=child_num_compat/f_num_compat
            child_probabilities=[proba,1-proba]
            for j,child_index in enumerate(node._child_indices):
                self._nodes[child_index]._long_description=self._nodes[child_index]._descriptor+',p('+str(child_probabilities[j])+'),'+str(len(self._nodes[child_index]._known_answers))
        node._EV=sum(self._nodes[son_index]._EV*child_probabilities[j] for j,son_index in enumerate(node._child_indices))
      else:
        if node._depth==self._k:
          node._EV=len(node._known_answers)
          node._best_sons=[]
        else:
          son_indices=node._child_indices
          node._EV=max([self._nodes[son_index]._EV for son_index in son_indices])
          node._best_sons=[son_index for son_index in son_indices if self._nodes[son_index]._EV==node._EV]
  
    
  def compute_best_lists(self):
    self._best_indices=[0]
    self._best_parents=[]
    open=self._nodes[0]._best_sons
    self._nodes[0]._best_description=self._nodes[0]._long_description+','+str(self._nodes[0]._EV)
    while len(open)>0:
      node_index=open.pop(0)
      node=self._nodes[node_index]
      self._best_indices.append(node_index)
      self._best_parents.append(self._best_indices.index(self._parents[node_index-1]))
      if node._isquestion:
        son_indices=[idx+1 for idx in range(len(self._parents)) if self._parents[idx] == node_index]
        for son_index in son_indices:
          open.append(son_index)
        node._best_description=node._long_description+','+str(node._EV)
      else:
        son_indices=node._best_sons
        for son_index in son_indices:
          open.append(son_index)
        node._best_description=node._long_description+','+str(node._EV)
  
  def render_best(self):
    Nodes=[Node(self._nodes[0]._best_description)]
    for i in range(len(self._best_indices)-1):
      Nodes.append(Node(self._nodes[self._best_indices[i+1]]._best_description,parent=Nodes[self._best_parents[i]]))
    for pre, fill, node in RenderTree(Nodes[0]):
      print("%s%s" % (pre, node.name))

  def render(self):
    Nodes=[Node(self._nodes[0]._long_description)]
    for i in range(len(self._nodes)-1):
      Nodes.append(Node(self._nodes[i+1]._long_description,parent=Nodes[self._parents[i]]))
    for pre, fill, node in RenderTree(Nodes[0]):
      print("%s%s" % (pre, node.name))
  

  def dot_render(self):
    Nodes=[Node(self._nodes[0]._long_description)]
    for i in range(len(self._nodes)-1):
      Nodes.append(Node(self._nodes[i+1]._long_description,parent=Nodes[self._parents[i]]))
    for Line in RenderTreeGraph(Nodes[0]):
      print(Line)

  def dot_export(self):
    Nodes=[Node(self._nodes[0]._long_description)]
    for i in range(len(self._nodes)-1):
      Nodes.append(Node(self._nodes[i+1]._long_description,parent=Nodes[self._parents[i]]))
    e = dotexport.DotExporter(Nodes[0])
    e.to_dotfile(str(self._n)+'-'+str(self._k)+'.dot')
    
  def build_whole_tree(self):
    tic=time.time()
    current_level=0
    current_isquestion=False
    current_state='questions'
    previous_state='answer'
    in_step_number=1
    next_level_len=1
    while len(self._open_nodes)>0:
      if self._nodes[self._open_nodes[0]]._isquestion != current_isquestion:
          current_isquestion= not(current_isquestion)
          if current_isquestion:
              current_state='questions'
              previous_state='answer'
          else:
              current_state='answers'
              previous_state='question'
          tac=time.time()
          print('\n',previous_state, ' level ', current_level, 'completed in', tac-tic, 'seconds')
          tic=tac
          next_level_len= len(self._open_nodes)
          print('next level has',next_level_len , current_state )
          print(' ')
          current_level+=1
          in_step_number=1
      if in_step_number%100==0:    
          print('\r opening ',current_state, ' ... ' , in_step_number , '/', next_level_len, end='' )
      self.open_first_node()
      in_step_number+=1
      
  def build_partial_tree(self,strategy):
      while len(self._open_nodes)>0:
        self.open_first_node(strategy)

    
tic=time.time()
k=9
tree=Elic_Tree(k+1,k)
tree.build_partial_tree('NAIVE')
#tree.render()
tree.compute_expected_values()
tree.compute_best_lists()
tree.render_best()

print('new algo optimized with ',k, 'questions took',time.time()-tic)

